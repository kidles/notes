## 声明方式
- let
- const
- var

## 值类型
- string
- number
- boolean
- undefined
- null
- symbol
- BitInt

## 引用类型
- object
  - array
  - function
  - RexEx
  - 。。。

## 检测
### 检测值类型
- typeof x
- typeof(x)
### 检测原型链
- x instanceof X
- X.isPrototypeOf(X)

## 遍历方式
- for i++
- for in
- for of
  - 遍历，映射，归并，过滤
  - x.forEach
  - x.map
  - x.reduce
  - x.filter

## 转换
### 数字转字符串
- num.toString()
- String(num)
- num+''
### 字符串转数字
- +str
- Number(str)
- parseInt(str)
- parseFloat(str)
### 字符串转数组
- [...str]
- str.split('')
- Array.from(str)
### 数组转字符串
- arr.join('')
### 对象转数组
- Object.keys()
- Object.values()
- Object.entries(obj)
  - [[k,v],[]]
### nodelist转数组
- [...nodelist]
- Array.form(nodelist,mapfn,this)

## 改变this
- 立即执行
  - call(this,arg1,arg2...)
  - apply(this,[arg1,arg2])
- 返回函数
  - bind(this)

## 拷贝
### 浅拷贝
- copy = [...arr];copy = {...obj}
- copy = Object.assign(arr1,arr2)
- 使用其他遍历方式，都是浅拷贝
### 深拷贝
- 使用其他库
- 递归函数里遍历,遍历里判断类型
```javascript
function copy(obj){
  let res = obj instanceof Array?[]:{};
  for(let key in obj){
    res[key] = typeof obj[key]=='object'?copy(obj[key]):obj[key];
  }
  return res
}
```


## 原型
- 实例化对象.\_\_proto\_\_ == 构造函数.prototype
- 构造函数.prototype.\_\_proto\_\_ == Object.prototype
- 构造函数.\_\_proto\_\_.\_\_ptoto\_\_ == Object.prototype
- Object.prototype.\_\_ptoto\_\_ == null
- 非构造函数的对象.prototype == undefined
- 
- 设置获取a的原型
  - `Object.setPrototypeOf(a,b)`
  - `Object.getPrototypeOf(a)`
  - 知道对象获取构造函数
  - `Object.getPrototypeOf(a).constructor`
- 检测原型链
  - `a instanceof b`
  - `b.isPrototypeOf(a)`
- 原型链上没有某个方法，使用其他对象call/apply
  - `Math.max.call(this,...Object.values(a))`
  - `Math.max.apply(this,Object.values(a))`
- 继承
  - Member构造函数继承User，通过原型设置
  - `Member.prototype.__proto__ = User.prototype;`

## class类和对象
- 原理：原型和原型链
- 默认严格模式
  - constructor
  - class里的方法都定义在原型上，实例化的对象共用
  - 
  - public 公共属性 
    - 类和对象都能使用
  - protect 
    - 保护属性 
    - 本类和继承的类能使用 
    - 实现：_属性/Symbol()
  - private 
    - 私有属性 
    - 只能本类使用 
    - 事项：#属性/#方法=()=>{}